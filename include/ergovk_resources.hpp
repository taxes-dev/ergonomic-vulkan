#pragma once
#include <concepts>
#include <memory>
#include <string>
#include <unordered_map>
#include "ergovk_result.hpp"

namespace ergovk::resources
{
	/**
     * @brief Key type for resources managed by ergovk::resources::ResourceSet.
    */
	using ResourceID = std::string;

	/**
     * @brief Errors generated by erogvk::resources classes.
    */
	enum class ResourceError
	{
		/**
         * @brief The resource with the given resource ID isn't present in the resource set.
        */
		ResourceNotPresent,
		/**
		 * @brief End of enum marker
		*/
		End,
	};

	/**
     * @brief Used as a tag to handle polymorphic instances of ergovk::resources::ResourceSet<T>.
    */
	class ResourceSetBase
	{
	public:
		virtual ~ResourceSetBase(){};

	protected:
		ResourceSetBase(){};
	};

	/**
     * @brief Concept for ensuring \p T is a resource set (derived from
     * ergovk::resources::ResourceSetBase).
    */
	template <typename T>
	concept IsResourceSet = std::derived_from<T, ResourceSetBase>;

	/**
     * @brief Manages a set of resources with type \p T, referencing them by a
     * named ergovk::resources::ResourceID.
     * @tparam T is the type to hold in the resource set.
    */
	template <typename T>
	class ResourceSet : public ResourceSetBase
	{
	public:
		/**
         * @brief The type of pointer used by this ResourceSet.
        */
		using ResourcePtr = std::shared_ptr<T>;

		/**
         * @brief Create a new, empty ResourceSet.
        */
		ResourceSet(){};
		~ResourceSet() override{};
		ResourceSet(const ResourceSet&) = delete;
		ResourceSet(ResourceSet&&) noexcept = default;
		ResourceSet& operator=(const ResourceSet&) = delete;
		ResourceSet& operator=(ResourceSet&&) noexcept = default;

		/**
         * @brief Returns whether or not this set contains a resource with the specified \p resource_id.
         * @param resource_id ergovk::resources::ResourceID
         * @returns True if a resource with the specified \p resource_id exists in this set; otherwise, false.
        */
		bool contains(const ResourceID& resource_id) const { return this->m_resources.contains(resource_id); };

		/**
         * @brief Attempt to retrieve a resource with the given \p resource_id from this set.
         * @param resource_id ergovk::resources::ResourceID
         * @returns ResourcePtr if the resource exists, otherwise a ergovk::resources::ResourceError value.
        */
		Result<ResourcePtr, ResourceError> get(const ResourceID& resource_id) const
		{
			if (this->contains(resource_id))
			{
				return this->m_resources.at(resource_id);
			}
			return ResourceError::ResourceNotPresent;
		}

		/**
         * @brief Inserts a \p resource with the specified \p resource_id into this set. If a resource already
         * exists with the specified \p resource_id, it will be replaced.
         * @param resource_id ergovk::resources::ResourceID
         * @param resource ResourcePtr
         * @returns True if \p resource was inserted, false if it was assigned to an existing resource ID.
        */
		bool insert(const ResourceID& resource_id, ResourcePtr resource)
		{
			auto [iter, result] = this->m_resources.insert_or_assign(resource_id, resource);
			return result;
		};

		/**
         * @brief Removes the resource with specified \p resource_id from this set and returns it.
         * @param resource_id ergovk::resources::ResourceID
         * @returns ResourcePtr if the resource exists, otherwise a ergovk::resources::ResourceError value.
        */
		Result<ResourcePtr, ResourceError> release(const ResourceID& resource_id)
		{
			auto node = this->m_resources.extract(resource_id);
			if (node.empty())
			{
				return ResourceError::ResourceNotPresent;
			}
			return std::move(node.mapped());
		};

		/**
         * @brief Resets this resource set to an empty state.
        */
		void reset() { this->m_resources.clear(); };

		/**
         * @brief Gets the number of items in this resource set.
         * @returns std::size_t
        */
		std::size_t size() const { return this->m_resources.size(); };

	private:
		std::unordered_map<ResourceID, ResourcePtr> m_resources{};
	};
}