#pragma once
#include <concepts>
#include <functional>
#include <memory>
#include <string_view>
#include <variant>
#include <vulkan/vulkan.h>
#include <vk_mem_alloc.h>

#ifndef NDEBUG
#define ERGOVK_DEBUG
#endif

namespace vkb
{
    class InstanceBuilder;
}

namespace ergovk
{
    /// @brief Errors generated by VulkanInstanceBuilder::build()
    enum class InitializeError
    {
        /// @brief Could not create an allocator (VMA)
        AllocatorCreate,
        /// @brief Initial creation of VkInstance failed
        FailedCreate,
        /// @brief Cannot find a GPU that matches the requirements for rendering
        NoSuitableGpu,
        /// @brief The surface creation callback did not return a valid surface
        SurfaceCreate
    };

    /** @brief Convert an error enum to a human readable string
     * @param error ergovk::InitializeError value
     * @return std::string_view
     */
    std::string_view error_to_string(const InitializeError &error);

    /** @brief Constraint to validate if \p T is an enumeration
     * @tparam T a type to check
     * @return true if \p T is an enumeration, otherwise false
     */
    template <typename T>
    concept IsEnum = std::is_enum<T>::value;

    /** @brief Used for returning results from a function that can fail.
     * @tparam TOk is the type of result when successful
     * @tparam TError is an enumeration that represents an error
     */
    template <typename TOk, IsEnum TError>
    using Result = std::variant<TOk, TError>;

    /** @brief Checks a \p result for a valid result
     * @param result ergovk::Result<TOk, TError>
     * @return true if \p result contains a valid result, otherwise false
     */
    template <typename TOk, IsEnum TError>
    inline bool is_ok(const Result<TOk, TError> &result) { return std::holds_alternative<TOk>(result); }

    /** @brief Checks \p result for an error
     * @param result ergovk::Result<TOk, TError>
     * @return true if \p result contains an error enum, otherwise false
     */
    template <typename TOk, IsEnum TError>
    inline bool is_error(const Result<TOk, TError> &result) { return std::holds_alternative<TError>(result); }

    /** @brief Gets the error contained in \p result
     * @param result ergovk::Result<TOk, TError>
     * @return a \p TError value
     */
    template <typename TOk, IsEnum TError>
    const TError &get_error(const Result<TOk, TError> &result)
    {
        assert(is_error(result));
        return std::get<TError>(result);
    }

    /** @brief Gets the value contained in \p result
     * @param result ergovk::Result<TOk, TError>
     * @return a \p TOk value
     * @note \p TOk must be copyable
     */
    template <typename TOk, IsEnum TError>
        requires std::is_copy_assignable<TOk>::value
    const TOk &get_value(const Result<TOk, TError> &result)
    {
        assert(is_ok(result));
        return std::get<TOk>(result);
    }

    /** @brief Moves the value out of \p result
     * @param result ergovk::Result<TOk, TError>
     * @return a \p TOk value
     * @note \p TOk must be movable
     */
    template <typename TOk, IsEnum TError>
        requires std::is_move_assignable<TOk>::value
    [[nodiscard]]
    TOk &&unwrap(Result<TOk, TError> &result)
    {
        assert(is_ok(result));
        return std::get<TOk>(std::move(result));
    }

    /// @brief Represents the currently running Vulkan context and manages its resources.
    class VulkanInstance
    {
        friend class VulkanInstanceBuilder;

    public:
        VulkanInstance(const VulkanInstance &) = delete;
        VulkanInstance(VulkanInstance &&) = default;
        ~VulkanInstance();
        VulkanInstance &operator=(const VulkanInstance &) = delete;
        VulkanInstance &operator=(VulkanInstance &&) = default;

        /** @brief Get the VkInstance handle for this instance
         * @return VkInstance
         */
        const VkInstance &get_instance() const { return this->m_instance; }

        /** @brief Gets the minimum uniform buffer offset alignment, needed for properly aligning data in descriptors
         * @return VkDeviceSize
         */
        VkDeviceSize get_min_uniform_buffer_offset_alignment() const
        {
            if (this->m_physical_device)
            {
                return this->m_physical_device_properties.limits.minUniformBufferOffsetAlignment;
            }
            return 0;
        }

    private:
        VulkanInstance(){};

        VkInstance m_instance{VK_NULL_HANDLE};
        VkDebugUtilsMessengerEXT m_debug_messenger{VK_NULL_HANDLE};
        VkSurfaceKHR m_surface{VK_NULL_HANDLE};
        VkDevice m_device{VK_NULL_HANDLE};
        VkPhysicalDevice m_physical_device{VK_NULL_HANDLE};
        VkPhysicalDeviceProperties m_physical_device_properties{};
        VkQueue m_graphics_queue{VK_NULL_HANDLE};
        VmaAllocator m_allocator{VK_NULL_HANDLE};
        std::uint32_t m_graphics_queue_family{0};
    };

    /// @brief Builds a valid ergovk::VulkanInstance
    class VulkanInstanceBuilder
    {
    public:
        /// @brief Callback signature used with \p set_create_surface_callback()
        using CreateSurfaceCallback = std::function<VkSurfaceKHR(VkInstance)>;

        /// @brief Creates a new empty ergovk::VulkanInstanceBuilder
        VulkanInstanceBuilder();
        ~VulkanInstanceBuilder();
        VulkanInstanceBuilder(const VulkanInstanceBuilder &) = delete;
        VulkanInstanceBuilder(VulkanInstanceBuilder &&) = default;
        VulkanInstanceBuilder &operator=(const VulkanInstanceBuilder &) = delete;
        VulkanInstanceBuilder &operator=(VulkanInstanceBuilder &&) = default;

        /** @brief REQUIRED: Used when the builder needs to create a VkSurfaceKHR for rendering
         * @param callback ergovk::VulkanInstanceBuilder::CreateSurfaceCallback
         * @note \p callback is not retained after the call to \p build()
         */
        VulkanInstanceBuilder &set_create_surface_callback(CreateSurfaceCallback &&callback);

        /** @brief OPTIONAL: In debug builds, use this to create a custom messenger for validation layers
         * @param callback PFN_vkDebugUtilsMessengerCallbackEXT
         * @note \p callback must be addressable for the lifetime of the ergovk::VulkanInstance
         */
        VulkanInstanceBuilder &set_custom_debug_callback(PFN_vkDebugUtilsMessengerCallbackEXT callback);

        /** @brief Attempts to create an ergovk::VulkanInstance from the parameters stored in this builder
         * @return Result<std::unique_ptr<ergovk::VulkanInstance>, ergovk::InitializeError>
         */
        [[nodiscard]] Result<std::unique_ptr<VulkanInstance>, InitializeError> build() const;

    private:
        vkb::InstanceBuilder *m_builder{nullptr};
        CreateSurfaceCallback m_create_surface_callback{};
    };

}